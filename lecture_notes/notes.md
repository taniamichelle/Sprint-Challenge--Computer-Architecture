- AND: can be used to clear bits to 0 or mask bits
- OR: can be used to set bits to 1
- shift + AND: can be used to extract specific bit(s)

-ALU: part of circuitry that does math operations and comparisons; used for logic
-Stack: can be used for temporary var storage, return address from subroutine, storage of registers and CPU state while handling an interrupt, allocation of local var for subroutine
-Interrupts: commonly generated by peripherals who need to alert CPU that some work needs to be done (e.g. a key has been pressed and must be handled)

-Stack can store the current state of the processor when an interrupt occurs; execution occurs at the address of the interr handler (PC points to interr handler). After the handler completes, the processor state is popped off the stack and execution of code resumes

-Subroutines: think of them as functions, but can't pass arguments and has no return values. Returns us to where we left off rather than returning a value
-CALL: in assembly, we CALL a subroutine at a particular address. Takes one operand (return address) so we know where to go when we hit the RET instruction; CPUs tend to use the stack for this. CALL will push the address of the instruction after it onto the stack, then move the PC to the subroutine address.
-RET: once subroutine has been called and runs, we return from that subroutine to pick up where we left off, just like a function. RET pops the return address (stored by CALL) off the stack and stores it in PC.

-JMP: Like call function but w/o RET. "call" it: compute address we're jumping to by looking it up in register and set PC to that. Don't increment PC as directly set it! If we auto-increment instruction length: some flags will need to be cleared

-Instruction layout: AABCDDDD. AA Number of operands for this opcode, 0-2. B 1 if this is an ALU operation. C 1 if this instruction sets the PC
DDDD Instruction identifier (important for auto-incrementing instruction length. jump PCs are set by instructions so they have a 'C').

- Code to extract the instruction length from the opcode on the LS8 (auto-increments): `inst_len = ((ir & 0b11000000) >> 6) + 1 # 3 pc += inst_len`
